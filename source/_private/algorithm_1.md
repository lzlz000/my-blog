---
title: 数据结构与算法笔记_1
typora-root-url: ../
date: 2016-11-12 11:13:32
tags:
---

算法效率的度量

### 算法的复杂度

#### 时间复杂度

算法的执行时间需要通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。同一个算法用不同语言实现，或不同的编译程序进行编译，或者在不同的计算机上运行，效率均不相同。使用绝对的时间单位衡量算法的效率是不合适的。

抛开计算机硬件软件相关的因素，可以认为一个特定算法“运算工作量”的大小只依赖于问题的规模（通常用整数n表示）。 一般情况下，算法中基本操作重复执行的次数是问题规模n

例如如下所示的冒泡排序算法中，判断并交换数组中两相邻两个元素的值是算法的“基本操作”，整个算法的执行时间与该基本操作重复执行次数的n的平方成正比，记作 **T(n)=O(n^2)**

```
for(int i =1;i<arr.length;i++) {
    for(int j=0;j<arr.length-i;j++) {
        if(arr[j]>arr[j+1]) {
            int temp = arr[j];
            arr[j]=arr[j+1];
            arr[j+1]=temp;
        }
    }
}
```

一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数**f(n)**， 算法的时间量度记作 

**T(n)=O(f(n))**

称为算法的**渐近时间复杂度**，简称**时间复杂度**。

![常见函数的增长率](/images/1565580847594.png)

在很多算法中，基本操作重复执行次数随问题输入集合不同而不同。在上述冒泡排序的例子中，便是如此。一种解决办法是计算它的平均值，即考虑它对所有输入数据集的期望值，此时相应的时间复杂度为算法的**平均时间复杂度**。假设输入集合arr可能出现的所有n!种排列概率相等，则平均时间复杂度T(n)=O(n^2),最坏情况下,arr种的初始序列为自大到小反向有序，此时T(n)=O(n^2)，和平均时间复杂度是一个级别。

实际上最坏时间复杂度和平均时间复杂度都是有意义的度量标准，例如在另一种排序算法-快速排序种，最坏情况下**T(n)=O(n^2)**，但是在大多数情况下它的复杂度为**T(n)=O(nlogn)**,而且是所有排序算法中效率最好的

#### 空间复杂度

类似时间复杂度，空间复杂度作为算法所需存储空间的量度，记作

**S(n)=O(f(n))**

注意空间复杂度指的是除了输入数据以外需要占用的额外空间

### 线性表 

线性表的表示方式：数组 链表

| 特点、常用方法                 | 数组 | 链表   |
| ------------------------------ | ---- | ------ |
| 占用空间                       | 小   | 大     |
| 扩容                           | 需要 | 不需要 |
| add(Object element)            | O(1) | O(1)   |
| add(int index, Object element) | O(n) | O(n)   |
| get(int index)                 | O(1) | O(n)   |
| contains(Object element)       | O(n) | O(n)   |
| remove(Object o)               | O(n) | O(1)   |
| remove(int index)              | O(n) | O(n)   |



